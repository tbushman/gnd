doctype html
html
	head
		title= appTitle
		meta(name="viewport", content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no")
		//meta(http-equiv="x-dns-prefetch-control" content="on")
		link(rel="stylesheet", href="/stylesheets/gpo.css", type="text/css")
		link(rel="stylesheet", href="/stylesheets/style.css", type="text/css")
		link(href="https://fonts.googleapis.com/css?family=Overpass,Merriweather", rel="stylesheet")
		link(rel="stylesheet", href="/stylesheets/leaflet.css")
		link(rel="stylesheet", href="/stylesheets/leaflet.draw.css")
		script(type="text/javascript", src="/scripts/jquery.min.js")
		script(src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js")
		script(type="text/javascript", src="/scripts/vue-pick-a-date.js")
		script(type="text/javascript", src="/scripts/marked.min.js")
		script(type="text/javascript", src="/scripts/d3.v3.min.js")
		script(type="text/javascript", src="/scripts/moment-with-locales.min.js")
		script(type="text/javascript", src="/scripts/leaflet.js")
		script(type="text/javascript", src="/scripts/Leaflet.Editable.js")
		//- script(type="text/javascript", src="/scripts/DrawCanvas.js")

	body(style="pointer-events: none;")
		block page
			
		block header
		block content
				
		#map(style="pointer-events: all;")
		a#publish_logo(href="https://github.com/tbushman/gnd" target="_blank")
			img(src="/images/publish_logo.svg")
		
		script(type="text/javascript").
			Vue.prototype.moment = moment;
			Vue.prototype.marked = marked;
			Vue.prototype.$ = $;
			Vue.prototype.DatePicker = DatePicker;
			//- Vue.directive('drawcanvas', {
			//- 	inserted(can, binding, vnode)
			//- 	{
			//- 		var self = this;
			//- 		can.width = self.cW;
			//- 		can.height = self.cH;
			//- 		//- console.log(can, binding, vnode)
			//- 		var ctx = can.getContext('2d');
			//- 			ctx.fillStyle = '#000'
			//- 		ctx.fill();
			//- 		//- console.log(self.can)
			//- 		//- self.can = can
			//- 	},
			//- 	update(can, binding, vnode) {
			//- 
			//- 	}
			//- })
			//- Vue.use(drawcanvas);
			Vue.use(DatePicker);
			new Vue({ el: '#select',
				data() {
					return { 
						months: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
						menu: this.parseObj(!{JSON.stringify(menu)}),
						pu: this.ifNullThenObj(!{JSON.stringify(pu)}),//{properties: {}},
						dat: this.parseObj(!{JSON.stringify(dat)}),
						data: this.parseObj(!{JSON.stringify(data)}),
						doc: this.parseObj(!{JSON.stringify(doc)}),
						dids: [],
						did: (this.parseObj(!{JSON.stringify(doc)}) === '' ? 0 : this.parseObj(!{JSON.stringify(doc)}).index),
						//- infowindow: this.parseObj(!{JSON.stringify(infowindow)}),
						//- index: this.parseObj(!{JSON.stringify(index)}),
						//- pageIndex: this.parseObj(!{JSON.stringify(pageIndex)}),
						// substrates, filling
						drawtype: this.parseObj(!{JSON.stringify(drawtype)}),
						// blog, draw, map
						type: this.parseStr(!{JSON.stringify(type)}),
						//- layer: this.parseObj(!{JSON.stringify(layer)}),
						rep: {
							// TODO map: ['Community Organizer'],
							'ZIP4': ['resident', 'landlord', 'Community Organizer'],
							City: ['Council Member', 'Mayor'],
							State: ['House of Representatives', 'Senate'],
							County: ['Council Member', 'Mayor']
						},
						//- pageIndex: null,
						//- drawtype: null,
						layer: null,
						radiusSupported: false,
						nextCount: 0,
						touchMap: {},
						foundRotationAngle: false,
						scale: 1,
						mousePressed: false,
						//- drawCoalesced: false,
						//- loadedLayer: this.loadedCanvas(),
						can: null,
						//document.getElementById('maincanvas'),
						ctx: null,
						image: null,
						cW: window.innerWidth,
						cH: window.innerHeight,
						rX: 35,
						rY: 35,
						// favor drawtype
						//- erase: false,
						cursor: 'pointer',
						//- mode: 'blog',
						ranks: ["first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth", "ninth", "tenth"],
						keys: ["tools", "filling"],
						loggedin: this.parseObj(!{JSON.stringify(session.loggedin)}),
						info: '',
						ff: this.parseObj(!{JSON.stringify(ff)}),
						uploadchtitle: null,
						dragind: null,
						latlngs: null,
						repitem: [],
						avail: this.parseBool(!{JSON.stringify(avail)}),
						pickerbegin: false,
						pickerend: false,
						beginDate: '',
						endDate: '',
						zoom: 6,
						sliderIndex: 0,
						n: 0,
						accordions: 
							(
								this.parseObj(!{JSON.stringify(dat)}) !== '' ?
								[
									this.parseObj(!{JSON.stringify(dat)}).map(function(data){return []})
								] :
								[[]]
							)
					}
				},
				mounted() {
					var self = this;
					
					document.addEventListener('keydown', function(event) {
					  var keyName = event.key;
						if (keyName === 'Enter') event.preventDefault()
					  //alert('keypress event\n\n' + 'key: ' + keyName);
					});
					$(document).on('click', '.href', function(e){
						e.stopPropagation();
					});
					$(document).ready(function(){

						$('.dropdown').not('.mainmenu').slideUp(100);
						$('.drop').slideUp(100);
						
						$('.selected').removeClass('selected');

					});
					self.sliderImg();
					self.dids = (self.data && self.data !== '' ? self.data.map(function(doc){
						return doc.index;
					}) : [(!self.doc || self.doc === '' ? 0 : self.doc.index)] );
					self.dids.sort();
					if (!self.doc) {
						if (self.data) {
							self.doc = self.data[0]
							console.log(self.doc)
						} else {
							if (self.dat[0]) {
								self.data = [].concat.apply([], self.dat);
							}
						}
						self.dids = [self.doc.index];
						self.did = 0;
						//- self.doc = (!self.data ? (!self.dat ? '': self.dat[0][0]) : self.data[0]);
					}
					if (self.pu && self.pu.properties.time) {
						self.beginDate = moment(self.pu.properties.time.begin).utc().format();
						self.endDate = moment(self.pu.properties.time.end).utc().format();
					}
					if (self.pu && self.pu.properties.title) {
						
						self.changePlace({
							target: {value:self.pu.properties.title}
						});
					}
					if (!self.image) {
						self.image = $('#img')[0]
					}
					if (!self.can) self.can = $('#maincanvas')[0];
					if (self.doc) {
						self.loadMap(function(dataLayer){
							/*if (!map) return;
							self.map = map;
							self.dataLayer = dataLayer;*/
							if (!dataLayer) return;
							self.dataLayer = dataLayer
							//- var point = self.map.latLngToLayerPoint(new L.LatLng(self.doc.geometry.coordinates[0], self.doc.geometry.coordinates[1]))
							var bounds = self.dataLayer.getBounds();
							self.map.fitBounds(bounds);
							console.log(dataLayer)
							if (dataLayer)
								self.dataLayer.enableEdit();
							self.lMarker = L.marker(self.map.getCenter(), {draggable: true}).addTo(self.map);
							if (!self.image && self.doch) {
								self.drawImg(function(img){
									self.img = img;
								});
							}//- self.panZoom();
						})
					}
				},
				//- directives: {
				//- 
				//- 		drawCanvas: function(can, binding, vnode)
				//- 		//- {
				//- 		//- 
				//- 		//- 	self.drawTouch2()
				//- 		//- }
				
				watch: {
					can: function() {
						console.log("drawTouch changed");
					}
				},
				methods: {
					formatDate(date){
						return moment(date).utc().format();
					},
					pickerOpen(which, time){
						var self = this;
						if (which === 'begin') {
							self.pickerend = false;
							self.pickerbegin = true;
							self.beginDate = (time !== '' ? moment(time).utc().format() : moment().utc().format())
						}else {
							self.pickerbegin = false;
							self.pickerend = true;
							self.endDate = (time !== '' ? moment(time).utc().format() : moment().utc().format())

						}
					},
					ifNullThenObj(ob) {
						if (!ob) return {properties: {placetype:'', title:'', time: {begin:moment().utc().format(), end: moment().utc().format()}}};
						return ob;
					},
					parseBool: function(item) {
						if (!item) return false;
						return true;
					},
					parseStr(item) {
						if (!item) return '';
						return item;
					},
					parseObj(ob) {
						if (!ob) return '';
						return ob;
					},
					sliderImg(){
						var self = this;
						if ($('#slider')[0]) {
							setInterval(function(){
								$('#slider').css('opacity',0);
								setTimeout(function(){
									if (self.sliderIndex > 3) {
										self.sliderIndex = 1
									} else {
										self.sliderIndex += 1;
									}
									setTimeout(function(){
										$('#slider').css('opacity',1);
									},2000)
									
								},2000)
							},10000)
						}
					},
					dropdown(e) {
						var self = this;
						//e.preventDefault();
						console.log(e.target)
						var that, main;
						if ($(e.target).hasClass('mainmenu')) {
							that = $('#tlmodules.dropdown');
							main = true;
						} else {
							that = e.target;
							main = false;
						}
						console.log(that, main)
						if ($(that).hasClass('selected')) {
							if (main && $('div.menu').hasClass('blog')) {
								$(that).slideUp(100);
								$(that).removeClass("selected");
							} else {
								if ($('div.menu').hasClass('blog')) {
									$(that).next('.drop').slideUp(100);
									
								}
							}
						} else {
							if (main && $('div.menu').hasClass('blog')) {
								$(that).slideDown(200);
								$(that).addClass('selected');
							} else {
								self.type = 'blog';
								$(that).next('.drop').slideDown(200);
							}
						}
					},
					setBegin(e) {
						var self = this;
						if (!self.pu.properties.time) self.pu.properties.time = {};
						self.pu.properties.time.begin = e.target.value; 
					},
					setEnd(e) {
						var self = this;
						if (!self.pu.properties.time) self.pu.properties.time = {};
						self.pu.properties.time.end = e.target.value; 
					},
					changeTitle(e) {
						var self = this;
						//- if (!self.pu.properties.title) {
						self.pu.properties.title = e.target.value
					},
					changePlace(e) {
						var self = this;
						var etargetvalue = e.target.value;
						console.log(e)
						console.log(e.target.value)
						console.log(self.rep[e.target.value])

						if (!self.pu.properties) {
							self.pu.properties = {}
							self.pu.properties.placetype = etargetvalue
						} else {
							self.pu.properties.placetype = etargetvalue
						}
						self.repitem = self.rep[etargetvalue]
						console.log(self.repitem)
					},
					accordion: function(n, ind) {
						var self = this;
						if (self.accordions[n].indexOf(ind) === -1) {
							self.accordions[n].push(ind);
							self.accordions[n].sort();
						} else {
							self.accordions[n].splice(self.accordions[n].indexOf(ind), 1);
						}
					},
					getCursor() {
						var self = this;
						if (self.cursor !== 'pointer') {
							return "url('/images/tools/tools_"+(self.drawtype === 'substrates' ? 0 : 1)+".svg'), "+self.cursor+""
						}
					},
					initSig() {
						var self = this;
						self.type = 'draw';
						self.drawtype = 'filling';
						

					},
					drawImg(cb) {
						var self = this;
						var img = new Image();
						img.src = (self.drawtype === 'filling' ? '/images/filling/filling_0.svg' : '/images/substrates/substrates_0.svg')//self.doc.content[self.index].image;
						//- var can = $('#maincanvas')[0];
						//- var cx = can.getContext('2d');
						//- if (img.complete && img.naturalHeight !== 0) {
						//- 	cx.drawImage(img, 0, 0, self.cW, self.cH);
						//- } else {
						//- 	img.onload = function () {
						//- 		cx.drawImage(img, 0, 0, self.cW, self.cH);
						//- 	}
						//- }
						cb(img)

					},
					setDrawType(drawtype, e) {
						var self = this;
						self.drawtype = drawtype;
						self.menu = 'draw';
						//- switch(self.menu) {
						//- 	case 'draw':
						//- 		break;
						//- 	case 'blog':
						//- 		break;
						//- 	case 'map':
						//- 		break;
						//- 	default:
						//- 
						//- }
					},
					loadedCanvas() {
						
					},
					startD(e) {
						var self = this;
						if (!self.can) {
							self.can = e.target;
							self.ctx = can.getContext('2d');
							if (!self.image) self.image = $('#img')[0];
						}
					},
					endD(e) {
						
					},
					mouseHandler(event) {
						var self = this;
						if (event.type == "mousedown" && event.button === 0) {
							self.mousePressed = true;
						}
							
						if (self.mousePressed && event.button === 0) {
							var fakeTouch = {
								identifier : 10,
								pageX : event.pageX,
								pageY : event.pageY
							};
							//- console.log(fakeTouch)
							var eventType = (event.type ===  "mousedown" ? "touchstart" :
									(event.type == "mouseup" ? "touchend" : "touchmove"));
							
							//- self.image.onload = function() {
								self.drawTouch(event.target, fakeTouch, eventType);
								event.preventDefault();
							//- }
						}

						if (event.type == "mouseup")
							self.mousePressed = false;
					},
					touchHandler(event) {
						var self = this;
						event.preventDefault();
						
						for (var i = 0; i < event.changedTouches.length - 1; i++) {
							self.drawTouch(
								//- event
								event.target, event.changedTouches[i], event.type
							);
						}
						
					},
					drawTouch2() {
						var self = this;
						drawThis = self.image;
						var drawtype = self.drawtype;//'filling';
						var layer = 0;
						var can = (!self.can ? $('#maincanvas')[0] : self.can);
						can.width = self.cW;
						can.height = self.cH;
						//- can.style.width = self.cW + 'px'
						//- can.style.height = self.cH + 'px'
						//- if (!self.ctx) 
						var ctx = can.getContext('2d');
						//- ctx.imageSmoothingEnabled = false;
						if (eventType === "touchend") {
							self.rX++;
							self.rY++;
							
						}
						self.cursor = 'grabbing'
						//- console.log(self.image)
						if (
							self.drawtype === 'substrates'
							//- $('#erase').val() !== ''
						) {
							//- eventTarget.setAttribute('style', 'cursor: url("/images/icons/tools_'+0+'.svg"), grabbing;');
							ctx.fillStyle = 'rgba(0,0,0,1)';
							ctx.globalCompositeOperation = "destination-out";//context.createPattern(pCanvas, 'no-repeat');
							//- ctx.fill()
						} else {
							//- var c = document.createElement('canvas');
							//- c.width = self.cW;
							//- c.height = self.cH;
							//- c.style.width = self.cW + 'px';
							//- c.style.height = self.cH + 'px';
							//- var cx = c.getContext('2d');
							//- //- ctx.globalCompositeOperation = "source-in";
							//- //- eventTarget.setAttribute('style', 'cursor: url("/images/icons/tools_'+1+'.svg"), grabbing;');
							//- var pCanvas = document.createElement('canvas');
							//- pCanvas.width = self.cW;
							//- pCanvas.height = self.cH;
							//- pCanvas.style.width = self.cW + 'px';
							//- pCanvas.style.height = self.cH + 'px';
							//- var pContext = pCanvas.getContext('2d');
							//- pContext.drawImage(drawThis, 0, 0, self.cW, self.cH);
							//- var pPattern = cx.createPattern(pCanvas, 'repeat');
							ctx.fillStyle = '#000'
							//pPattern;
							//- console.log(ctx)
							//- ctx.fillStyle = pPattern;
							//- ctx.fill()
							//- console.log(ctx)
						}
						ctx.beginPath();
						//- ctx.save();
						ctx.moveTo(touch.pageX, touch.pageY);
						//- ctx.translate(touch.pageX, touch.pageY);
						//- ctx.scale(1, self.rY/self.rX);
						//- ctx.arc(0, 0, self.rX, 0, 2.0 * Math.PI, false);
						ctx.arc(touch.pageX, touch.pageY, self.rX, 0, 2.0 * Math.PI, false);
						//- ctx.fill()
						//- ctx.closePath();
						//- ctx.restore();
						ctx.fill();
						self.can = can
					},
					drawTouch(eventTarget, touch, eventType) {
						//
						//- console.log(e)
						var self = this;
						//- var eventTarget = e.target, 
						//- touch = {pageX: e.pageX, pageY: e.pageY}, 
						//- eventType = e.type, 
						drawThis = self.image;
						var drawtype = self.drawtype;//'filling';
						var layer = 0;
						//- if (!self.can) self.can = eventTarget;
						var can = (!eventTarget ? $('#maincanvas')[0] : eventTarget);
						can.width = self.cW;
						can.height = self.cH;
						//- can.style.width = self.cW + 'px'
						//- can.style.height = self.cH + 'px'
						//- if (!self.ctx) 
						var ctx = can.getContext('2d');
						//- ctx.imageSmoothingEnabled = false;
						if (eventType === "touchend") {
							self.rX++;
							self.rY++;
							
						}
						self.cursor = 'grabbing'
						//- console.log(self.image)
						if (
							self.drawtype === 'substrates'
							//- $('#erase').val() !== ''
						) {
							//- eventTarget.setAttribute('style', 'cursor: url("/images/icons/tools_'+0+'.svg"), grabbing;');
							ctx.fillStyle = 'rgba(0,0,0,1)';
							ctx.globalCompositeOperation = "destination-out";//context.createPattern(pCanvas, 'no-repeat');
							//- ctx.fill()
						} else {
							//- var c = document.createElement('canvas');
							//- c.width = self.cW;
							//- c.height = self.cH;
							//- c.style.width = self.cW + 'px';
							//- c.style.height = self.cH + 'px';
							//- var cx = c.getContext('2d');
							//- //- ctx.globalCompositeOperation = "source-in";
							//- //- eventTarget.setAttribute('style', 'cursor: url("/images/icons/tools_'+1+'.svg"), grabbing;');
							//- var pCanvas = document.createElement('canvas');
							//- pCanvas.width = self.cW;
							//- pCanvas.height = self.cH;
							//- pCanvas.style.width = self.cW + 'px';
							//- pCanvas.style.height = self.cH + 'px';
							//- var pContext = pCanvas.getContext('2d');
							//- pContext.drawImage(drawThis, 0, 0, self.cW, self.cH);
							//- var pPattern = cx.createPattern(pCanvas, 'repeat');
							ctx.fillStyle = '#000'
							//pPattern;
							//- console.log(ctx)
							//- ctx.fillStyle = pPattern;
							//- ctx.fill()
							//- console.log(ctx)
						}
						ctx.beginPath();
						//- ctx.save();
						ctx.moveTo(touch.pageX, touch.pageY);
						//- ctx.translate(touch.pageX, touch.pageY);
						//- ctx.scale(1, self.rY/self.rX);
						//- ctx.arc(0, 0, self.rX, 0, 2.0 * Math.PI, false);
						ctx.arc(touch.pageX, touch.pageY, self.rX, 0, 2.0 * Math.PI, false);
						//- ctx.fill()
						//- ctx.closePath();
						//- ctx.restore();
						ctx.fill();
						self.can = can
					},
					getAdjustedRotationAngle(angle) {
						return angle * Math.PI / 180;
					},
					saveImage(){
						var self = this;
						self.can.toBlob(function(blob) {
							var fd = new FormData();
							fd.append(name, blob);
							
							// endpoint uses multer
							var uploadurl = '/api/uploadmedia/'+self.pageIndex+'/'+self.index+'/'+self.drawtype+'/'+self.layer+'';

							$.ajax({
								url: uploadurl,
								type: 'POST',
								data: fd,
								processData: false,
								contentType: false,
								success: function(response) {
									$('#inputimg').val(response.replace('/var/www/pu', '').replace('/Users/traceybushman/Documents/pu.bli.sh/pu', ''));
									self.mode = 'blog';
								}
							})
						}, 'image/png', 0.95);
					},
					checkNameValidity(type, aSearchTerm, aMsg, event)
					{
						var self = this;
						var elem = event.target;//document.getElementById(aID);
						for (var i = 0; i < elem.value.length; i++) {
							if (aSearchTerm.indexOf(elem.value.charAt(i)) !== -1) {
								elem.setAttribute("aria-invalid", "true");
								//- addAlert(aMsg);
							} else {
								elem.setAttribute("aria-invalid", "false");
								//- removeOldAlert();
							}
						}
						var check = elem.value;
						if (check !== '') {
							//var check = $(elem).val();
							var url = check.replace(' ', '_');
							$.post('/check/'+check).done(function(result){
								self.avail = (result === 'Available')
								if (self.avail) {
									$.post('/reserve/'+check+'');
									if (self.pu[type]) {
										self.pu[type] = check;
									} else if (self.pu.properties[type]) {
										self.pu.properties[type] = check;
									}
								}
							})
						}
					},
					checkEmailValidity(e)
					{
						var elem = e.target;//document.getElementById(aID);
						//- console.log(aSearchTerm)
						var rX = new RegExp('/^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/')
						if (rX.test(elem.value)) {
							elem.setAttribute("aria-invalid", "false");
						} else {
							elem.setAttribute("aria-invalid", "true");
						}
					},
					panZoom: function(){
						var self = this;
						$.post('/panzoom/'+self.map.getCenter().lat+'/'+self.map.getCenter().lng+'/'+self.map.getZoom()+'', function(result){
						})
					},

					loadMap(cb) { 
						var self = this, dataLayer, 
						map = new L.map('map', { 
							//- maxBounds: L.latLngBounds([L.LatLng(43,-122),L.LatLng(-7,-188)]),
							center: (!self.doc || !self.doc.geometry.coordinates ? L.latLngBounds([40.7608, -111.8910]).getCenter() : L.latLngBounds(self.rxArr(self.doc.geometry.coordinates)).getCenter() ),

							//- L.latLngBounds(
								//- [
								//- 	(!self.doc.geometry.coordinates[1] ? 40.7608 : self.doc.geometry.coordinates[1]),
								//- 	(!self.doc.geometry.coordinates[0] ? -111.8910 : self.doc.geometry.coordinates[0])
								//- ]
															//- ).getCenter(),
							zoomControl: false, 
							zoom: 6,//(!self.position ? 6 : self.position.zoom), 
							minZoom: 4,	maxZoom: 18,
							editable: true,//(self.pu && self.pu.admin),
							renderer: L.canvas(),
							preferCanvas: true
						});
						//- console.log(map)
						L.control.zoom({ position:'bottomleft' }).addTo(map);
						var opts = { 
							attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="http://cartodb.com/attributions">CartoDB</a>',
							renderer: L.canvas({padding:0.5}),
							bounds: map.getBounds().pad(1000)
						};
						var t = 'https://api.mapbox.com/styles/v1/tbushman/ciq7gm0ov008kbfm580v9mm9c/tiles/256/{z}/{x}/{y}@2x?access_token=pk.eyJ1IjoidGJ1c2htYW4iLCJhIjoiSmI0aU94OCJ9.SZytljBzoWupPUYeu_OR9A'
						L.tileLayer(t, opts).addTo(map);

						map.on('zoomend', function(){ 
							if (self.doc) self.refreshMap(self.rxArr(self.doc.geometry.coordinates)) 
						});
						self.map = map;
						if (!self.dataLayer && self.data) {
							self.loadFeatures(self.data, cb);
						} else { 
							cb(self.dataLayer); 
						} 
					},

					/*************** Begin utility and maintenance  scripts ***************/
					rxOrNo(arr) { 
						// TODO -- better conditional for whole planet
						return ( arr[0] < arr[1] ? arr.reverse() : arr ) 
					},
					rxArr(arr) {
						var self = this;
						if (!Array.isArray(arr[0])) return self.rxOrNo(arr);
						var rxa = arr.map(function(ar){ if (!Array.isArray(ar[0])) { 
							return self.rxOrNo(ar) } else if (Array.isArray(ar)) {
								return ar.map(function(a){ if (!Array.isArray(a[0])) { 
									return self.rxOrNo(a) } else if (Array.isArray(a)) {
										return a.map(function(b){ if (!Array.isArray(b[0])) { 
											return self.rxOrNo(b) } else if (Array.isArray(b)) {
												return b.map(function(c){ 
							if (!Array.isArray(c[0])) {return self.rxOrNo(c) }
							else {return} })} else {return} })} else {return} })} else {return}
						});
						console.log(arr)
						return arr; 
					} /*Leaflet requires reversed geo-coordinate (lat, lng)*/,
					evalTime(time) {/*some time ranges in data require difference calc*/
						if (typeof time === 'Array') {
							let ntime = eval(time[0] - time[1])
							time = ntime;
						} else if (typeof time === 'Number') {

						} else {
							let now = new Date(), nYear = now.getFullYear(), nMonth = now.getMonth(), nDay = now.getDate();
							let then = new Date(time), yr = then.getFullYear(), mo = then.getMonth(), dy = then.getDate();
							const is30 = [8,3,5,10];
							const is31 = [0,2,4,6,7,9,11];
							const is28 = [1];
							let l = 0;
							function lp(d){
								let ret;
								ret = (l % 4 === 0 ? (d / 28) : (d / 29));
								return ret;
							}
							time = (nYear - yr) - (( nMonth / 11 ) - ( mo / 11 )  ) + ( 
								( is30.indexOf(nMonth) === -1 ?
										( is31.indexOf(nMonth) === -1 ?
									 			lp(nDay) : (nDay / 31)
										) :
										( nDay / 30 )
								) 
								- 
								( is30.indexOf(mo) === -1 ?
										( is31.indexOf(mo) === -1 ?
									 			(dy / 28) : (dy / 31)
										) :
										( dy / 30 ) 
								)
							)
						}
						return time; 
					},
					debounceF(fn) { /* skittle scroll speed */ 
						clearTimeout(this.dTimeout);
						this.dTimeout = setTimeout(fn, 1000); 
					},
					loadFeatures(ft, cb) {
						var self = this, dataLayer;
						var customIcon = L.icon({
							iconUrl: '/images/buttonmarker.svg',
							iconSize: [33, 33]
						});
					
						if (self.dataLayer) self.dataLayer.remove(); 
						var dataLayer = L.GeoJSON.geometryToLayer(self.doc, {
									// MongoDB stores coordinates as [lng, lat]
									// Leaflet uses [lat, lng]
									
									onEachFeature: function (feature, layer) {
										if (feature.geometry.type === 'Point') {
										}
										if (feature.geometry.type === 'Polygon') {
											//layer.setLatLngs(self.doc.geometry.coordinates[0])
											//self.latlngs = layer.getLatLngs()
										}
										
									},
									geometryToLayer: function(feature) {
										if (feature.geometry.type === 'Polygon') {
											//console.log(feature.geometry.type )
											var geojsonPolygonOptions = {
												fillColor: 'var(--highlight)',
												color: '#fff',
												weight: 2,
												opacity: 1,
												fillOpacity: 0.8,
												className: feature._id
												
											};
											var polygon = L.polygon(self.rxArr(feature.geometry.coordinates), geojsonPolygonOptions);
											//polygon.enableEdit();
											//polygon.on('dblclick', L.DomEvent.stop).on('dblclick', dataLayer.toggleEdit);
											return polygon;
										}
									},
									pointToLayer: function (feature, latlng) {
										if (feature.geometry.type === 'Point') {
											//console.log(feature)
											var geojsonMarkerOptions = {
												radius: 11,
												fillColor: 'var(--highlight)',
												color: '#fff',
												weight: 2,
												opacity: 1,
												fillOpacity: 0.8,
												className: feature._id+'@'+map.latLngToLayerPoint(latlng).x+','+map.latLngToLayerPoint(latlng).y+''
											};
											var circleMarker = L.circleMarker(latlng, geojsonMarkerOptions);
											return circleMarker;
										}
										
									}
								})//.addTo(map);
								
								//cb(map, dataLayer)
								self.map.addLayer(dataLayer);
						cb(dataLayer); 
					} /*map geatures*/,
					refreshMap(cd){ 
						var self = this, 
						lat,
						lng,
						center = self.map.getCenter();
						if (self.shape && self.shape !== '') {
							self.shape.remove();
						}
						if (!cd) { 
							lat = center.lat; lng = center.lng;
						} else if (Array.isArray(cd[0])) {
							self.shape = L.polygon(cd).addTo(self.map);
							lat = self.shape.getBounds().getCenter().lat;
							lng = self.shape.getBounds().getCenter().lng;
						} else { 
							lat = cd[0]; lng = cd[1]; 
						}
					// console.log(lat, lng)
						if (lat && lng) { 
							let latlng = new L.LatLng(lat, lng), nl;
							
							self.map.panTo(latlng);
							self.zoom = self.map.getZoom(); 
						}
					},
					toggleEdit: function(ind) {
						var self = this;
						this.edit = (!this.edit ? ind : null);
					},
					addMapBlob: function() {
						var self = this;
						var ind = self.doc.properties.media.length;
						$('div.centerallwrap').css('pointer-events', 'auto')
						self.dataLayer.disableEdit();
						self.addNewMedia(self.doc._id, ind, function(){
							//var canvas = document.querySelector('canvas.leaflet-zoom-animated');
							leafletImage(self.map, function(err, canvas){
								if (err) {
									return console.log(err)
								}
								$('a[id*=deletemedia]').hide();
								var im = new Image()
								im.src = canvas.toDataURL('image/png');
								im.onload = function(){
									self.checkImage(im, canvas, im.width, im.height, 1025, 1025, ind, 'map');
									setTimeout(function(){
										var img = document.querySelector('img#return'+ind+'');
										var can = $('#canvas'+ind+'')[0];
										var w = img.width;
										var h = img.height;
										can.width = w;
										can.height = h;
										var ctx = can.getContext("2d");
										ctx.drawImage(img, 0, 0, w, h);
										self.uploadBlob(img, can, ind, function(){
											//console.log(canvas)
											var dataurl = can.toDataURL("image/png", 0.8);
											self.doc.properties.media[ind].thumb = dataurl.replace(/data:image\/png;base64,/, '');
										})
											/**/
										
										
									},2000)
								}
								
							})
							
							
							
						});
						
					},
					//- addNewSignature(id, index, cb) {
					//- 	var self = this;
					//- 	$.post('/api/newsignature/'+id+'/'+index+'', function(res) {
					//- 		self.doc.properties.sig.push(res);
					//- 		cb()
					//- 	})
					//- },
					addNewMedia: function(id, index, cb) {
						var self = this;
						$.post('/api/newmedia/'+id+'/'+index+'', function(res) {
							self.doc.properties.media.push(res);
							cb()
						})
					},
					handleFile: function(did, index) {
						var self = this;
						self.did = did;
						self.file = document.getElementById('media_'+index).files[0];
						self.processImage(index);
					},
					processImage: function(imgindex) {
						var self = this;
						var dataurl = null;
						var file = self.file;
						if (!file) return;
						var imagefile = file.type;
						var imageTypes= ["image/jpeg","image/png","image/jpg","image/svg+xml"];
						if(imageTypes.indexOf(imagefile) === -1) {
							$("#info").html("<span class='msg-error'>Please Select A valid Image File</span><br /><span>Only jpeg, jpg, png, and pdf types allowed</span>");
							return false;
							
						} else {
							var reader = new FileReader();
							
							reader.onloadend = function(e) {
								var img = document.getElementById('return'+imgindex+'');
								img.src = e.target.result;
								var type = imagefile.split('image/')[1];
								img.onload = function() {
									$('#media').val('');
									var can = $('#canvas'+imgindex+'')[0];
									var maxWidth = 1025 ;
									var maxHeight = 1025 ;
									var w = img.width;
									var h = img.height;
									can.width = w;
									can.height = h;
									var ctx = can.getContext("2d");
									ctx.drawImage(img, 0, 0);
									self.checkImage(img, can, w, h, maxWidth, maxHeight, imgindex, type);
								}
								
							}
							reader.readAsDataURL(file);
						}
					},
					checkImage: function(img, can, w, h, maxWidth, maxHeight, imgindex, imgtype) {
						var self = this;
						if (h > maxHeight || w > maxWidth) {
							self.reSize(img, can, w, h, maxWidth, maxHeight, imgindex, imgtype)
						} else {
							if (imgtype === 'map') {
								var im = document.querySelector('img#return'+imgindex+'');
								im.setAttribute('src', can.toDataURL('image/png'))
							} else {
								if (maxHeight === 400) {
									self.drawThumb(img, can, w, h, imgindex, imgtype)
								} else {
									self.drawFull(img, can, w, h, imgindex, imgtype)
								}
							}
						}
						
					},
					reSize: function(img, can, w, h, maxWidth, maxHeight, imgindex, imgtype){
						can.height = h*0.99;
						can.width = w*0.99;

						var can2 = document.createElement('canvas');
						can2.width = w*0.99;
						can2.height = h*0.99;
						var ctx2 = can2.getContext('2d');
						var ctx = can.getContext('2d');
						ctx2.drawImage(img, 0, 0, w*0.99, h*0.99);
						ctx.drawImage(can2, 0, 0, w*0.99, h*0.99, 0, 0, w*0.99, h*0.99);
						w = w*0.99;
						h = h*0.99;
						img.width = w;
						img.height = h;
						this.checkImage(img, can, w, h, maxWidth, maxHeight, imgindex, imgtype)
					},
					uploadBlob: function(img, can, imgindex, cb) {
						var self = this;
						var orientation = 'portrait'
						if (can.width > can.height) { 
							orientation = 'landscape' 
						} else { 
							orientation = 'portrait' 
						}

						if (!HTMLCanvasElement.prototype.toBlob) {
						 Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {
							value: function (callback, type, quality) {
								var binStr = atob( this.toDataURL(type, quality).split(',')[1] ),
								len = binStr.length,
								arr = new Uint8Array(len);
								for (var i = 0; i < len; i++ ) {
									arr[i] = binStr.charCodeAt(i);
								}
								callback( new Blob( [arr], {type: type || 'image/png'} ) );
							}
						 });
						}
						can.toBlob(function(blob) {
							var fd = new FormData();
							fd.append("img", blob);
							var uploadurl = '/api/uploadmedia/'+self.doc.index+'/'+imgindex+'/png';
							$.ajax({
								url: uploadurl,
								type: 'POST',
								data: fd,
								processData: false,
								contentType: false,
									success: function(response) { 
									img.onload = function () {
										self.doc.properties.media[imgindex].image_abs = response;
										self.doc.properties.media[imgindex].image = response.replace('/var/www/pu', '').replace('/Users/traceybushman/Documents/pu.bli.sh/pu', '');
										self.doc.properties.media[imgindex].thumb_abs = response;
										self.doc.properties.media[imgindex].thumb = response.replace('/var/www/pu', '').replace('/Users/traceybushman/Documents/pu.bli.sh/pu', '');
										self.doc.properties.media[imgindex].orientation = orientation;
										cb();
									}
									img.src = response.replace('/var/www/pu', '').replace('/Users/traceybushman/Documents/pu.bli.sh/pu', '');
								}
							})
						}, 'image/png');
					},
					drawFull: function(img, can, w, h, imgindex, imgtype) {
						var self = this;
						can.height = h;
						can.width = w;
						var ctx = can.getContext('2d');
						console.log(w,h)
						ctx.drawImage(img, 0, 0, w, h);
						self.uploadBlob(img, can, imgindex, function(){
							var can = $('#canvas'+imgindex+'')[0];
							var maxWidth = 400 ;
							var maxHeight = 400 ;
							var w = img.width;
							var h = img.height;

							self.checkImage(img, can, w, h, maxWidth, maxHeight, imgindex, imgtype);
						})
						
					},
					drawThumb: function(img, can, w, h, imgindex, imgtype) {
						var self = this;
						can.height = h;
						can.width = w;
						var ctx = can.getContext('2d');
						
						ctx.drawImage(img, 0, 0, w, h);
						var dataurl = can.toDataURL("image/png", 0.8);
						setTimeout(function(){
							self.doc.properties.media[imgindex].thumb = dataurl.replace(/data:image\/png;base64,/, '');
							//$('#inputthumb'+imgindex+'').val(dataurl.replace(/data:image\/png;base64,/, ''));
							
						}, 100);
					},

				}
			});
		
		script(type='text/javascript', src='/scripts/leaflet-image_0_4_0.js')
		script(type="text/javascript", src="/scripts/Path.Drag.js")

