extends layout
block page
	if (username)
		- var menu = 'profile'
	else
		- var menu = 'home'
block content
	if (doc)
		- var menuData = doc
		- var pageIndex = pageindex
	else
		if (pageindex)
			- var pageIndex = pageindex
			- var menuData = data[pageindex]
		else
			- var pageIndex = data[data.length-1].pageindex
			if (data[data.length-1].content[data[data.length-1].content.length-1].substrates[0] !== undefined)
				- var menuData = data[data.length-1]
			else
				- var menuData = data[0]
	if (index)
		- var contentData = menuData.content[index]
		- var imageUrl = contentData.substrates[contentData.substrates.length-1].image
	else
		if (menuData.content[menuData.content.length-1].substrates[0] !== undefined)
			- var index = menuData.content[menuData.content.length-1].index
			- var contentData = menuData.content[menuData.content.length-1]
			- var imageUrl = contentData.substrates[0].image
		else
			if (menuData.content[menuData.content.length-1].substrates[menuData.content[menuData.content.length-1].substrates.length-1] !== undefined)
				- var index = menuData.content[menuData.content.length-1].index
				- var contentData = menuData.content[menuData.content.length-1]
				- var imageUrl = contentData.substrates[contentData.substrates.length-1].image
			else
				- var index = 0
				- var contentData = menuData.content[0]
				if (contentData.substrates[0] !== undefined)
					- var imageUrl = contentData.substrates[0].image
				else
					- var imageUrl = ""
	input(type="hidden", value= pageIndex, id="pageindex")
		//-
			navigation
	div#select(class= type)
		include menu.pug
	
	//-
		initiate map + event listeners
	script(type="text/javascript").
		const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
		var data = `'#{data}'`
		/*var pageindex = '#{pageindex}'*/
		var pageIndex; 
		
		$(document).ready(function(){
			pageIndex = parseInt(document.getElementById('pageindex').value, 10);
			console.log('this pageindex'+pageIndex)
			var topmargin = document.querySelector('.pullquote').getBoundingClientRect().height;
			$('.grid-header.mainHeader').css('height', (topmargin + 30) + 'px');
			$('textarea').each(function(){
				var text;
				if ($(this).val()) {
					$(this).css('max-width', '100%')
				} else {
					//placeholder reliably contains updated text fsr
					text = $(this).attr('placeholder');
					$(this).val(text);
					$(this).css('max-width', '100%')
				} 
			});
			
			$('.list > .ms-Panel-main').css({display: 'none'})
			$('.list').removeClass('is-open')
			$('.list').css({display: 'none'})
			$('div.dropdown').slideUp(100);
			$('.drop').slideUp(100);
			$('.selected').removeClass('selected');
			InitializeApp();
		})
		
		//drop-down event listener
		$(document).on('click', 'a.dropdown', function (e) { 
			//e.preventDefault();
			var that, main;
			if ($(this).hasClass('mainmenu')) {
				$('.menu').css('height', 'var(--nowindowmenu)')
				that = $('#tlmodules.dropdown');
				main = true;
			} else {
				that = this;
				main = false;
			}
			if ($(that).hasClass('selected')) {
				if (main) {
					$(that).slideUp(100);
				} else {
					$(that).next('.drop').slideUp(100);
				}
				$(that).removeClass("selected");
				var topmargin = document.querySelector('.pullquote').getBoundingClientRect().height;
				$('.grid-header.mainHeader').css('height', topmargin + 30 + 'px');
			} else {
				$(that).addClass('selected');
				if (main) {
					$(that).slideDown(200);
				} else {
					$(that).next('.drop').slideDown(200);
				}
				setTimeout(function(){
					var topmargin = document.querySelector('.pullquote').getBoundingClientRect().height;
					$('.grid-header.mainHeader').css('height', topmargin + 30 + 'px');
				}, 210);
			}
			//e.stopPropagation();
		});
		//search
		/*$(document).on('change', '#mySearch', function(e){
			e.preventDefault();
			$('.searchbox').slideUp(100);
			$('.searchbox').remove();
			var term = $(e.target).val();
			console.log(term)
			$.get('/search/'+term+'').done(function(response){
				console.log(response)
				
				$(e.target).parent().append('<div id="dropdown" class="searchbox"></div>')
				if (response == 'none') {
					$('.searchbox').slideDown(200);
					$('.searchbox').append('<p class="drop ms-Grid-col ms-u-sm12">No pu.bli.sher by that name</p>')
				}
				for (var i in response) {
					$('.searchbox').slideDown(200);
					$('.searchbox').append('<a class="drop ms-Grid-col ms-u-sm12" href="/'+response[i].username+'"><span class="ms-font-l">'+response[i].username+'</span></a>')
				}
			})
		})*/
				
		//gallery
		$(document).on('click', 'a.thumbnail', function(e){
			e.preventDefault()
			var imgindex = $(this).attr('id')
			var userid = $(this).attr('name').split('@')[0]
			if ($(this).hasClass('gallery')) {
				var windex = $(this).attr('name').split('@')[1];
				//var index = windex.split('all_')[1];
				$.post('/gallery/'+pageid+'/'+windex+'/'+imgindex+'', function(){
					window.location.href = '/gallery/'+pageid+'/'+windex+'/'+imgindex+'/#scrollto_'+index+'@'+imgindex+''
				})
			} else {
				var windex = $(this).attr('name').split('@')[1];
				
				$.post('/gallery/'+pageid+'/'+windex+'/'+imgindex+'', function(){
					window.location.href = '/gallery/'+pageid+'/'+windex+'/'+imgindex+''
				})
			}
			return false;
		});
		
		//Timeline hovers
		/*$('.module').mouseleave(function(){
			$(this).children('.hovertext').remove();
			//$(this).children('p').remove();
			$(this).children('.overlay').remove();
			$('.module').removeClass('hover')
			if ($(this).css('z-index') > 0) {
				$(this).css('z-index', '1')
			}
		});
		$('.module').mouseenter(function(){
			var title = $(this).attr('title');
			var name = $(this).attr('name');
			$('.module').removeClass('hover');
			$(this).addClass('hover');
			$(this).prepend('<span class="ms-font-xs ms-fontWeight-light hovertext" style="text-align: left">'+title+'</span>')
			//$(this).append('<p class="ms-font-xs ms-fontWeight-light" style="text-align: left">'+name+'</p><div class="overlay"></div>')
			if ($(this).css('z-index') > 0) {
				$(this).css('z-index', '2')
			}
		});*/
		var datalength = #{data.length};
		var doc = `#{JSON.stringify(doc)}`;
		var lMarker;
		var medialength;
		var classname_a;
		var classname_b;
				
		//expand the edit-able sections
		$(document).on('click', '#editform', function(){
			if ($('#formshow').css('display') === 'none') {
				document.getElementById('select').className = 'map';
				document.getElementsByClassName('menu')[0].className = 'menu map';//+ #{type} +''
				document.getElementById('formshow').style.display = 'block';
				//$('#formshow').css('display', 'block');
				document.getElementById('map').style.visibility = 'visible';
				$('#editform > span').html('Hide Feature details');
				lMarker.dragging.enable();
				console.log(lMarker)
				beginFeatureDrag();
				//$('#map').css('display: block;')
								//$('#select > div.menu').removeClass('map');
				//$('#select > div.menu').addClass('map');
				//document.getElementsByClassName('menu blog').className = `#{type} menu`
			} else {
				document.getElementById('select').className = 'blog';
				document.getElementsByClassName('menu')[0].className = 'menu blog'
				//$('#formshow').css('display', 'none');
				document.getElementById('formshow').style.display = 'none';
				document.getElementById('map').style.visibility = 'visible';
				$('#editform > span').html('Show Feature details');
				lMarker.dragging.disable();
				endFeatureDrag();
				//$('#map').css('display: none');
				//$('#select > div.menu').removeClass('map');
				//$('div.menu').addClass('blog');

				//document.getElementsByClassName('menu '+#{type}).className = 'menu'
			}
		})
		$(document).on('click', '#editmedia', function(){
			if ($('#mediashow').css('display') === 'none') {
				$('#mediashow').css('display', 'block');
				$('#editmedia > span').html('Hide Media details')
			} else {
				$('#mediashow').css('display', 'none');
				$('#editmedia > span').html('Show Media details')
			}
		})
		
		$(document).on('click', '#editlayout', function(){
			if ($('#layoutshow').css('display') === 'none') {
				$('#layoutshow').css('display', 'block');
				$('#editlayout > span').html('Hide Layout details')
			} else {
				$('#layoutshow').css('display', 'none');
				$('#editlayout > span').html('Show Layout details')
			}
		});
		
		//edit mode
		$(document).on('click', '#deletefeature', function(){

			if ($('#deletefeature span').css('display') === 'block') {
				$(this).attr("href", "/api/deletefeature/"+pageIndex+"/"+#{index}+"");
			} else {
				$('#deletefeature span').css('display', 'block')
			}
		})
		//check / uncheck
		$(document).on('click', '.ms-ChoiceField-field', function(e){
			e.preventDefault;
			var that = $(this);
			var id = that.attr('id');
			if (that.siblings('input').hasClass('is-checked')) {
				that.siblings('input').removeClass('is-checked')
				that.siblings('input').attr('aria-checked', 'false')
				that.siblings('input').removeAttr('checked');
				$('#input_date2').parent('.ms-TextField').removeClass('is-disabled');
				
			} else {
				that.siblings('input').addClass('is-checked')
				that.siblings('input').attr('aria-checked', 'true');
				//that.siblings('input').attr('checked', 'checked');
				$('#input_date2').val('');
				$('#input_date2').parent('.ms-TextField').addClass('is-disabled');
			}
		})
		//live update of 'layout' / wip
		/*
				$('#inputtext').on('mouseup', function(e){
						
					var whole = e.target.value.split("")
					var selObj = window.getSelection();
					console.log(selObj.toString());
					var selRange = selObj.getRangeAt(0)
					console.log(selRange)
					var select = selObj.toString();
					
					whole.splice(selObj.focusOffset, selObj.length, "<span class='highlight'>"+select+"</span>");
					$('#previewtext').html(marked(whole.join("")))
				})
		*/
		$('#inputtext').on('keyup', function(e){
			$('#previewtext').html(marked(e.target.value))
		});
		$('input').on('keydown', function(e){
			if (e.key === 'Slash') {
				e.preventDefault();
			}
		})
		
		
		
		
		var radiusSupported = false;
		var nextCount = 0;
		var touchMap = {};
		var pointMode = (window.location.hash == "#points");
		var pointerEventDisabledMode = (window.location.hash == "#nopointer");
		var enableForce = false;
		var drawTouchMajor = true;
		var foundRotationAngle = false;
		var scale = 1;
		var mousePressed = false;
		var drawCoalesced = false;

		function InitializeApp() {
		    InitializeCanvas();

		    var elem = document.getElementById("canvas");
		    if (window.PointerEvent && !pointerEventDisabledMode) {
		        console.log("Adding PointerEvent listeners");
		        ["pointerdown", "pointermove", "pointerup"].forEach(function(e) {
		            elem.addEventListener(e, PointerHandler);
		        });
		    } else {
		        console.log("Adding MouseEvent & TouchEvent listeners");
		        ["mousedown", "mousemove", "mouseup"].forEach(function(e) {
		            elem.addEventListener(e, MouseHandler);
		        });
		        ["touchstart", "touchmove", "touchend"].forEach(function(e) {
		            elem.addEventListener(e, TouchHandler);
		        });
		    }

		    window.addEventListener("resize", function(e) {
		        InitializeCanvas();
		    });

		    document.addEventListener("keyup", function(e) {
		        switch(e.which) {
		        // ESC
		        case 27:
		            var canvas = document.getElementById("canvas");
		            canvas.getContext("2d").clearRect(0, 0, canvas.width, canvas.height);
		            break;

		        // p
		        case 80:
		            pointMode = !pointMode;
		            window.location.hash = pointMode ? "#points" : "";
		            break;

		        // f
		        case 70:
		            enableForce = !enableForce;
		            break;

		        // a
		        case 65:
		            drawTouchMajor = !drawTouchMajor;
		            break;

		        // c
		        case 67:
		            drawCoalesced = !drawCoalesced;
		            break;

		        // enter
		        case 13:
		            if (document.documentElement.webkitRequestFullscreen) {
		                if (document.webkitFullscreenElement)
		                    document.webkitCancelFullScreen();
		                else
		                    document.documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
		            }
		        }
		    });
		}

		function InitializeCanvas() {
		    var elem = document.getElementById("canvas");

		    var newscale = window.devicePixelRatio ? window.devicePixelRatio : 1;
		    var newwidth = window.screen.width * newscale;
		    var newheight = window.screen.height * newscale;

		    if (elem.width != newwidth || elem.height != newheight || scale != newscale) {
		        // resizing a canvas clears it, so do it only when it's dimensions have changed.
		        scale = newscale;
		        elem.width = newwidth;
		        elem.height = newheight;
		        elem.style.width = window.screen.width + "px";
		        elem.style.height = window.screen.height + "px";
		    }
		}

		function PointerHandler(event) {
		    event.preventDefault();
				console.log(event.type)
		    if (event.type == "pointerdown" && event.button === 0)
		        mousePressed = true;

		    if (mousePressed || event.type == "pointerup" || (event.buttons & 1)) {
		        var fakeTouch = {
		            identifier: event.pointerId,
		            pageX : event.pageX,
		            pageY : event.pageY,
		            radiusX : event.width,
		            radiusY : event.height,
		            force : event.pressure,
		        };
		        var eventType = event.type == "pointerdown" ? "touchstart" :
		            event.type == "pointerup" ? "touchend" : "touchmove";
		        event.preventDefault();
		        drawTouch(fakeTouch, eventType, false);

		        if (drawCoalesced && event.getCoalescedEvents) {
		            var points = event.getCoalescedEvents();
		            for(let coalesced of points) {
		                fakeTouch.pageX = coalesced.pageX;
		                fakeTouch.pageY = coalesced.pageY + 50;
		                fakeTouch.radiusX = coalesced.width;
		                fakeTouch.radiuxY = coalesced.height;
		                fakeTouch.force = coalesced.pressure;

		                drawTouch(fakeTouch, eventType, true);
		            }
		        }
		    }

		    if (event.type == "pointerup")
		        mousePressed = false;
		}

		function MouseHandler(event) {
		    if (event.type == "mousedown" && event.button === 0)
		        mousePressed = true;
		    if (mousePressed && event.button === 0) {
		        var fakeTouch = {
		            identifier : 10,
		            pageX : event.pageX,
		            pageY : event.pageY
		        };
		        var eventType = event.type == "mousedown" ? "touchstart" :
		            event.type == "mouseup" ? "touchend" : "touchmove";
		        drawTouch(fakeTouch, eventType, false);
		        event.preventDefault();
		    }

		    if (event.type == "mouseup")
		        mousePressed = false;
		}

		function TouchHandler(event) {
		    event.preventDefault();
		    for (var i = 0; i < event.changedTouches.length; i++)
		        drawTouch(event.changedTouches[i], event.type, false);
		}

		function drawTouch(touch, eventType, coalesced) {
		    var context = document.getElementById("canvas").getContext("2d");

		    // Map the identifier to a small count (no-op on Chrome, but
		    // important for mobile Safari).
		    if (!(touch.identifier in touchMap)) {
		        touchMap[touch.identifier] = nextCount;
		        nextCount++;
		    }

		    // Polyfill non-standard properties
		    if (!("radiusX" in touch) && "webkitRadiusX" in touch)
		        touch.radiusX = touch.webkitRadiusX;
		    if (!("radiusY" in touch) && "webkitRadiusY" in touch)
		        touch.radiusY = touch.webkitRadiusY;
		    if (!("rotationAngle" in touch) && "webkitRotationAngle" in touch)
		        touch.rotationAngle = touch.webkitRotationAngle;
		    if (!("force" in touch) && "webkitForce" in touch)
		        touch.force = touch.webkitForce;

		    var radiusX = getAdjustedRadius(touch.radiusX, touch.radiusY);
		    var radiusY = getAdjustedRadius(touch.radiusY, touch.radiusX);
		    var rotationAngle = getAdjustedRotationAngle(touch.rotationAngle);
		    foundRotationAngle = foundRotationAngle || rotationAngle;

		    // Try to avoid start/end ellipses overlapping exactly
		    if (eventType == "touchend") {
		        radiusX++;
		        radiusY++;
		    }

		    context.save();
		    context.translate(touch.pageX * scale, touch.pageY * scale);
		    context.rotate(rotationAngle);
		    context.scale(1, radiusY/radiusX);
		    context.beginPath();
		    context.arc(0, 0, radiusX, 0, 2.0 * Math.PI, false);
		    context.closePath();

		    // Fill the ellipse on start/move
		    if (eventType != "touchend") {
		        var opacity = pointMode ? 1 : 0.1;

		        var hue = (touchMap[touch.identifier] * 30) % 256;
		        if (coalesced)
		            hue += 10;
		        var lum = 40;
		        if (enableForce && touch.force)
		            lum = Math.round(touch.force / 0.4 * 50 + 20);
		        context.fillStyle = "hsla(" + hue + ",100%," + lum + "%, " + opacity + ")";
		        context.fill();
		    }

		    // Outline ellipse on start/end
		    if (eventType != "touchmove") {
		        context.strokeStyle = eventType == "touchstart" ? "black" : "grey";
		        context.lineWidth = 2;
		        context.stroke();
		    }

		    if (drawTouchMajor && foundRotationAngle) {
		        context.strokeStyle = "#fff";
		        context.lineWidth = 1;
		        context.beginPath();
		        if (radiusX >= radiusY) {
		            context.moveTo(-radiusX, 0);
		            context.lineTo(radiusX, 0);
		        } else {
		            // Note that this is also radiusX, because of the scaling above
		            context.moveTo(0, -radiusX);
		            context.lineTo(0, radiusX);
		        }
		        context.stroke();
		    }

		    context.restore();
		}

		function getAdjustedRadius(radius, otherRadius) {
		    if (pointMode)
		        return 1;

		    // Spec says to use 1 for unknown radius, can't differentiate between that
		    // and real 1 pixel radius.
		    var radiusUndefined = !radius || radius <= 1;
		    var otherRadiusUndefined = !otherRadius || otherRadius <= 1;

		    if (radiusUndefined) {
		        radius = otherRadiusUndefined? 15 : otherRadius;
		    }

		    if (radius > 100) {
		        console.error("Got large radius: " + radius);
		        radius = 100;
		    }

		    return radius * scale;
		}

		function getAdjustedRotationAngle(angle) {
		    return angle * Math.PI / 180;
		}